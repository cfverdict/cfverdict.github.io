{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 14, "column": 0}, "map": {"version":3,"sources":["file:///Users/yangbo85/Desktop/CF-Time-Machine/src/lib/api.ts"],"sourcesContent":["import { CFSubmission, CFUser, CFRatingChange } from '@/types/cf';\n\nconst CF_API_BASE = 'https://codeforces.com/api';\n\nasync function fetchCF<T>(endpoint: string, params: Record<string, string | number>): Promise<T> {\n  const url = new URL(`${CF_API_BASE}${endpoint}`);\n  Object.entries(params).forEach(([key, value]) => {\n    url.searchParams.append(key, String(value));\n  });\n\n  // 使用 Next.js 的 fetch，默认会有缓存行为\n  // 可以根据需要添加 { next: { revalidate: 3600 } } 来缓存 1 小时\n  const res = await fetch(url.toString(), {\n    next: { revalidate: 3600 } \n  });\n\n  if (!res.ok) {\n    throw new Error(`HTTP error! status: ${res.status}`);\n  }\n\n  const data = await res.json();\n\n  if (data.status !== 'OK') {\n    throw new Error(`CF API Error: ${data.comment}`);\n  }\n\n  return data.result as T;\n}\n\nexport async function getUserInfo(handle: string): Promise<CFUser> {\n  const result = await fetchCF<CFUser[]>('/user.info', { handles: handle });\n  return result[0];\n}\n\nexport async function getUserSubmissions(handle: string): Promise<CFSubmission[]> {\n  return fetchCF<CFSubmission[]>('/user.status', { handle });\n}\n\nexport async function getUserRatingHistory(handle: string): Promise<CFRatingChange[]> {\n  return fetchCF<CFRatingChange[]>('/user.rating', { handle });\n}\n"],"names":[],"mappings":";;;;;;;;AAEA,MAAM,cAAc;AAEpB,eAAe,QAAW,QAAgB,EAAE,MAAuC;IACjF,MAAM,MAAM,IAAI,IAAI,GAAG,cAAc,UAAU;IAC/C,OAAO,OAAO,CAAC,QAAQ,OAAO,CAAC,CAAC,CAAC,KAAK,MAAM;QAC1C,IAAI,YAAY,CAAC,MAAM,CAAC,KAAK,OAAO;IACtC;IAEA,8BAA8B;IAC9B,mDAAmD;IACnD,MAAM,MAAM,MAAM,MAAM,IAAI,QAAQ,IAAI;QACtC,MAAM;YAAE,YAAY;QAAK;IAC3B;IAEA,IAAI,CAAC,IAAI,EAAE,EAAE;QACX,MAAM,IAAI,MAAM,CAAC,oBAAoB,EAAE,IAAI,MAAM,EAAE;IACrD;IAEA,MAAM,OAAO,MAAM,IAAI,IAAI;IAE3B,IAAI,KAAK,MAAM,KAAK,MAAM;QACxB,MAAM,IAAI,MAAM,CAAC,cAAc,EAAE,KAAK,OAAO,EAAE;IACjD;IAEA,OAAO,KAAK,MAAM;AACpB;AAEO,eAAe,YAAY,MAAc;IAC9C,MAAM,SAAS,MAAM,QAAkB,cAAc;QAAE,SAAS;IAAO;IACvE,OAAO,MAAM,CAAC,EAAE;AAClB;AAEO,eAAe,mBAAmB,MAAc;IACrD,OAAO,QAAwB,gBAAgB;QAAE;IAAO;AAC1D;AAEO,eAAe,qBAAqB,MAAc;IACvD,OAAO,QAA0B,gBAAgB;QAAE;IAAO;AAC5D"}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///Users/yangbo85/Desktop/CF-Time-Machine/src/lib/stats.ts"],"sourcesContent":["import { CFSubmission, CFRatingChange } from '@/types/cf';\nimport { startOfYear, endOfYear, eachDayOfInterval, format } from 'date-fns';\n\nexport interface YearStats {\n  year: number;\n  totalSolved: number;\n  totalSubmissions: number;\n  maxRating: number;\n  longestStreak: number;\n  activeDays: number;\n  tagStats: Record<string, number>;\n  difficultyStats: Record<number, number>;\n  heatmapData: { date: string; count: number }[];\n  bestContest: CFRatingChange | null;\n}\n\nexport function calculateYearStats(\n  submissions: CFSubmission[],\n  ratingHistory: CFRatingChange[],\n  year: number\n): YearStats {\n  // Handle future years or invalid years gracefully\n  const now = new Date();\n  const targetDate = new Date(year, 0, 1);\n  const startDate = startOfYear(targetDate);\n  const endDate = endOfYear(targetDate);\n  \n  const startTs = startDate.getTime() / 1000;\n  const endTs = endDate.getTime() / 1000;\n\n  // Filter submissions for the year\n  const yearSubmissions = submissions.filter(\n    (s) => s.creationTimeSeconds >= startTs && s.creationTimeSeconds <= endTs\n  );\n\n  const acSubmissions = yearSubmissions.filter((s) => s.verdict === 'OK');\n  \n  // Unique solved problems\n  const solvedProblems = new Set<string>();\n  const tagStats: Record<string, number> = {};\n  const difficultyStats: Record<number, number> = {};\n  const dailyActivity: Record<string, number> = {};\n\n  // Re-iterate all year submissions for heatmap\n  yearSubmissions.forEach(sub => {\n    const dateStr = format(new Date(sub.creationTimeSeconds * 1000), 'yyyy-MM-dd');\n    dailyActivity[dateStr] = (dailyActivity[dateStr] || 0) + 1;\n  });\n\n  acSubmissions.forEach(sub => {\n    const problemId = `${sub.problem.contestId}-${sub.problem.index}`;\n    if (!solvedProblems.has(problemId)) {\n      solvedProblems.add(problemId);\n      \n      // Tags\n      sub.problem.tags.forEach(tag => {\n        tagStats[tag] = (tagStats[tag] || 0) + 1;\n      });\n\n      // Difficulty\n      if (sub.problem.rating) {\n        difficultyStats[sub.problem.rating] = (difficultyStats[sub.problem.rating] || 0) + 1;\n      }\n    }\n  });\n\n  // Longest Streak\n  let currentStreak = 0;\n  let longestStreak = 0;\n  \n  // Only calculate up to today if year is current year\n  const calcEndDate = (year === now.getFullYear()) ? now : endDate;\n  \n  // If year is in future, don't calculate streak\n  if (year <= now.getFullYear()) {\n      const days = eachDayOfInterval({ start: startDate, end: calcEndDate });\n      \n      days.forEach(day => {\n        const dateStr = format(day, 'yyyy-MM-dd');\n        if (dailyActivity[dateStr] && dailyActivity[dateStr] > 0) {\n          currentStreak++;\n        } else {\n          longestStreak = Math.max(longestStreak, currentStreak);\n          currentStreak = 0;\n        }\n      });\n      longestStreak = Math.max(longestStreak, currentStreak);\n  }\n\n  // Rating Stats\n  const yearRatings = ratingHistory.filter(\n    r => r.ratingUpdateTimeSeconds >= startTs && r.ratingUpdateTimeSeconds <= endTs\n  );\n  \n  let maxRating = 0;\n  let bestContest: CFRatingChange | null = null;\n  let maxRatingIncrease = -Infinity;\n\n  yearRatings.forEach(r => {\n    if (r.newRating > maxRating) maxRating = r.newRating;\n    const increase = r.newRating - r.oldRating;\n    if (increase > maxRatingIncrease) {\n      maxRatingIncrease = increase;\n      bestContest = r;\n    }\n  });\n\n  return {\n    year,\n    totalSolved: solvedProblems.size,\n    totalSubmissions: yearSubmissions.length,\n    maxRating,\n    longestStreak,\n    activeDays: Object.keys(dailyActivity).length,\n    tagStats,\n    difficultyStats,\n    heatmapData: Object.entries(dailyActivity).map(([date, count]) => ({ date, count })),\n    bestContest\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 163, "column": 0}, "map": {"version":3,"sources":["file:///Users/yangbo85/Desktop/CF-Time-Machine/src/components/ReportWrapper.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/components/ReportWrapper.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/components/ReportWrapper.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;;AAAA,uEAAuE;AACvE;;uCACe,IAAA,wQAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAAoS,GACjU,kEACA","ignoreList":[0]}},
    {"offset": {"line": 177, "column": 0}, "map": {"version":3,"sources":["file:///Users/yangbo85/Desktop/CF-Time-Machine/src/components/ReportWrapper.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/components/ReportWrapper.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/components/ReportWrapper.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;;AAAA,uEAAuE;AACvE;;uCACe,IAAA,wQAAuB,EAClC;IAAa,MAAM,IAAI,MAAM;AAAgR,GAC7S,8CACA","ignoreList":[0]}},
    {"offset": {"line": 191, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 199, "column": 0}, "map": {"version":3,"sources":["file:///Users/yangbo85/Desktop/CF-Time-Machine/src/app/report/%5Bhandle%5D/page.tsx"],"sourcesContent":["import { getUserInfo, getUserSubmissions, getUserRatingHistory } from '@/lib/api';\nimport { calculateYearStats } from '@/lib/stats';\nimport ReportWrapper from '@/components/ReportWrapper';\n\ntype Props = {\n  params: Promise<{ handle: string }>;\n};\n\nexport default async function ReportPage({ params }: Props) {\n  const { handle } = await params;\n  \n  try {\n    // Parallel data fetching\n    const [userInfo, submissions, ratingHistory] = await Promise.all([\n      getUserInfo(handle),\n      getUserSubmissions(handle),\n      getUserRatingHistory(handle)\n    ]);\n\n    const stats = calculateYearStats(submissions, ratingHistory, 2025);\n\n    return <ReportWrapper user={userInfo} stats={stats} />;\n  } catch (error) {\n    // Pass error to wrapper instead of rendering error UI directly\n    return <ReportWrapper error={(error as Error).message} />;\n  }\n}\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;;;;;AAMe,eAAe,WAAW,EAAE,MAAM,EAAS;IACxD,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM;IAEzB,IAAI;QACF,yBAAyB;QACzB,MAAM,CAAC,UAAU,aAAa,cAAc,GAAG,MAAM,QAAQ,GAAG,CAAC;YAC/D,IAAA,gIAAW,EAAC;YACZ,IAAA,uIAAkB,EAAC;YACnB,IAAA,yIAAoB,EAAC;SACtB;QAED,MAAM,QAAQ,IAAA,yIAAkB,EAAC,aAAa,eAAe;QAE7D,qBAAO,8OAAC,8IAAa;YAAC,MAAM;YAAU,OAAO;;;;;;IAC/C,EAAE,OAAO,OAAO;QACd,+DAA+D;QAC/D,qBAAO,8OAAC,8IAAa;YAAC,OAAO,AAAC,MAAgB,OAAO;;;;;;IACvD;AACF"}}]
}